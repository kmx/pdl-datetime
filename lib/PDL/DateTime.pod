=head1 NAME

PDL::DateTime - piddle for keeping high precision (microsecond) timestamps

=head1 DESCRIPTION

L<PDL::DateTime> is a subclass of L<PDL> piddle:

=over

=item * its PDL type is always C<LongLong> (64-bit signed integer)

=item * B<stored values are microseconds> since C<1970-01-01T00:00:00.000000Z> (can be both positive or negative)

=item * it is still a piddle so you can do all usual PDL arithmetic + L<PDL::DateTime> defines some new methods (see below)

=back

=head1 LIMITATIONS

=over

=item * supported datetimes are from C<0001-01-01T00:00:00.000000Z> (epoch microseconds: C<-62135596800000000>) to C<9999-12-31T23:59:59.999999Z> (epoch microseconds: C<253402300799999999>)

=item * leap seconds are completely ignored

=item * no timezone handling (module uses UTC)

=item * this module works only on perls with 64-bit integers, check C<perl -V:ivsize> (should be C<ivsize='8'>)

=item * no chance for nanoseconds precision, maybe in a separate module e.g. C<PDL::DateTime::Ns>

=back

=head1 FUNCTIONS

=head2 new

 my $p = PDL::DateTime->new($pdl_or_array_ref);
 # input data = microseconds (LongLong) since 1970-01-01T00:00:00Z (positive or negative)
 # input data are always converted to LongLong

=head2 new_from_epoch

 my $p = PDL::DateTime->new_from_epoch($pdl_or_array_ref);
 # BEWARE: precision in miliseconds only!
 # input data = seconds (int or double) since 1970-01-01T00:00:00Z (positive or negative)

=head2 new_from_ratadie

 my $p = PDL::DateTime->new_from_ratadie($pdl_or_array_ref);
 # BEWARE: precision in miliseconds only!
 # input data = days (int or double) since January 1, 0001 AD 00:00

See L<https://en.wikipedia.org/wiki/Rata_Die>

=head2 new_from_serialdate

 my $p = PDL::DateTime->new_from_serialdate($pdl_or_array_ref);
 # BEWARE: precision in miliseconds only!
 # input data = days (int or double) since January 1, 0000 AD 00:00

See L<http://www.mathworks.com/help/finance/handling-and-converting-dates.html>

=head2 new_from_juliandate

 my $p = PDL::DateTime->new_from_juliandate($pdl_or_array_ref);
 # BEWARE: precision in miliseconds only!
 # input data = days (int or double) since November 24, 4714 BC 12:00

See L<https://en.wikipedia.org/wiki/Julian_day>

=head2 new_from_datetime

 my $p = PDL::DateTime->new_from_datetime($array_ref);
 # input data = array of ISO 8601 date time strings

Supported formats - see L<Time::Moment|Time::Moment/from_string>.

=head2 new_from_parts

 my $p = PDL::DateTime->new_from_parts($y, $m, $d, $H, $M, $S, $U);
 # all arguments are either piddles or array refs
 # $y .. years (1..9999)
 # $m .. months (1..12)
 # $d .. days (1..31)
 # $H .. hours (0..23)
 # $M .. minutes (0..59)
 # $S .. seconds (0..59)
 # $U .. microseconds (0..999999)

=head2 new_from_ymd

 my $p = PDL::DateTime->new_from_ymd($ymd);
 # BEWARE: handles only dates!
 # $ymd (piddle or array ref) with dates like:
 # [ 20150831, 20150901, 20150902 ]

=head2 new_sequence

 my $p = PDL::DateTime->new_sequence($start, $count, $unit, $step);
 # $start .. ISO 8601 date time string (starting datetime) or 'now'
 # $count .. length of the sequence (incl. starting point)
 # $unit  .. step unit 'year', 'month', 'week', 'day', 'hour', 'minute', 'second'
 # $step  .. how many units there are between two seq elements (default: 1)

=head2 double_epoch

 my $dbl = $p->double_epoch;
 # BEWARE: precision loss, before exporting the time is truncated to miliseconds!
 # returns Double piddle

=head2 longlong_epoch

 my $epoch = $p->longlong_epoch;
 # BEWARE: precision loss, before exporting the time is truncated to seconds!
 # returns LongLong piddle

 # NOTE: $p->longlong_epoch is equivalent to: longlong(floor($p->double_epoch))
 # 1969-12-31T23:59:58        double_epoch = -2.0      longlong_epoch = -2
 # 1969-12-31T23:59:58.001    double_epoch = -1.999    longlong_epoch = -2
 # 1969-12-31T23:59:58.999    double_epoch = -1.001    longlong_epoch = -2
 # 1969-12-31T23:59:59        double_epoch = -1.0      longlong_epoch = -1
 # 1969-12-31T23:59:59.001    double_epoch = -0.999    longlong_epoch = -1
 # 1969-12-31T23:59:59.999    double_epoch = -0.001    longlong_epoch = -1
 # 1970-01-01T00:00:00        double_epoch =  0.0      longlong_epoch =  0
 # 1970-01-01T00:00:00.001    double_epoch =  0.001    longlong_epoch =  0
 # 1970-01-01T00:00:00.999    double_epoch =  0.999    longlong_epoch =  0
 # 1970-01-01T00:00:01        double_epoch =  1.0      longlong_epoch =  1

=head2 double_ratadie

 my $dbl = $p->double_ratadie;
 # BEWARE: precision loss, before exporting the time is truncated to miliseconds!
 # returns Double piddle

=head2 double_serialdate

 my $dbl = $p->double_serialdate;
 # BEWARE: precision loss, before exporting the time is truncated to miliseconds!
 # returns Double piddle

=head2 double_juliandate

 my $dbl = $p->double_juliandate;
 # BEWARE: precision loss, before exporting the time is truncated to miliseconds!
 # returns Double piddle

=head2 dt_ymd

 my ($y, $m, $d) = $p->dt_ymd;
 # returns 3 piddles: $y Short, $m Byte, $d Byte

=head2 dt_hour

 my $H = $p->dt_hour;
 # returns Byte piddle (values 0 .. 23)

=head2 dt_minute

 my $M = $p->dt_minute;
 # returns Byte piddle (values 0 .. 59)

=head2 dt_second

 my $S = $p->dt_second;
 # returns Byte piddle (values 0 .. 59)

=head2 dt_microsecond

 my $U = $p->dt_microsecond;
 # returns Long piddle (values 0 .. 999_999)

=head2 dt_day_of_week

 my $wd = $p->dt_day_of_week;
 # returns Byte piddle (values 1=Mon .. 7=Sun)

=head2 dt_day_of_year

 my $wd = $p->dt_day_of_year;
 # returns Short piddle (values 1..366)

=head2 dt_add

 my $p->dt_add($num, $unit);
 # adds $num datetime units
 # $num can be positive (addition) or negative (subtraction)
 # $unit .. "year", "month", "week", "day", "hour", "minute",
 #          "second", "millisecond", "microsecond"

 my $p->dt_add(day => 2);
 # turns e.g. 2015-08-20T23:24:25.123456Z
 # into       2015-08-22T23:24:25.123456Z

 my $p->dt_add(day => -2);
 # turns e.g. 2015-08-20T23:24:25.123456Z
 # into       2015-08-18T23:24:25.123456Z

 my $p->dt_add(day => 2, year => 3, month => 1);
 # turns e.g. 2015-08-20T23:24:25.123456Z
 # into       2018-09-22T23:24:25.123456Z

 #NOTE: supports also C<inplace>
 $p->inplace->dt_add(day => 2);


=head2 dt_truncate

 my $p->dt_truncate($unit);
 # $unit .. "year", "month", "week", "day", "hour", "minute",
 #          "second", "millisecond", "microsecond"

 my $p->dt_truncate('minute');
 # turns e.g. 2015-08-20T23:24:25.123456Z
 # into       2015-08-20T23:24:00.000000Z

 #NOTE: supports also C<inplace>
 $p->inplace->dt_truncate('minute');

=head2 dt_unpdl

 my $array = $p->dt_unpdl;
 my $array = $p->dt_unpdl($format);

 my $array = $p->dt_unpdl('%y-%m-%d %H:%M:%S');
 # returns perl arrayref with ISO 8601 date time strings

 my $array = $p->dt_unpdl('auto');
 # uses ISO 8601 format autodetected to be as short as possible
 # e.g. 2015-09-07T22:53 when all piddle values have 0 seconds and 0 microseconds
 # $format 'auto' is default when dt_unpdl is called without param

 my $array = $p->dt_unpdl('epoch');
 # returns perl arrayref (not a piddle) with epoch seconds as double
 # BEWARE: precision loss, before exporting the time is truncated to miliseconds!

 my $array = $p->dt_unpdl('epoch_int');
 # returns perl arrayref (not a piddle) with epoch seconds as integer values
 # BEWARE: precision loss, before exporting the time is truncated to seconds!

 my $array = $p->dt_unpdl('Time::Moment');
 # returns perl arrayref with Time::Moment objects

See L<Time::Moment|Time::Moment/strftime> (which we use for stringification) for supported formats.

=head2 dt_at

 my $datetime = $p->dt_at(@coords)
 #or
 my $datetime = $p->dt_at(@coords, $format)
 # returns ISO 8601 date time string for value at given piddle co-ordinates
 # optional $format arg - same as by dt_unpdl

=head2 dt_set

 $p->dt_set(@coords, $datetime_or_epoch);
 # sets $datetime_or_epoch as value at given piddle co-ordinates
 # $datetime_or_epoch can be ISO 8601 string or epoch seconds (double or int)

=head1 SEE ALSO

L<PDL>

=head1 LICENSE

This program is free software; you can redistribute it and/or modify it under the same terms as Perl itself.

=head1 COPYRIGHT

2015+ KMX E<lt>kmx@cpan.orgE<gt>
